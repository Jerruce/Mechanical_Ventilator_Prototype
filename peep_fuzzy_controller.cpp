/*++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/*                                                      */
/* File:  peep_fuzzy_controller.c                       */
/*                                                      */
/* Author: Automatically generated by Xfuzzy            */
/*                                                      */
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

#include <stdio.h>
#include <math.h>
#include "peep_fuzzy_controller.h"

/*======================================================*/
/*  MembershipFunction MF_xfl_singleton                 */
/*======================================================*/

/*------------------------------------------------------*/
/* Function to compute an equal relationship            */
/*------------------------------------------------------*/

static double MF_xfl_singleton_equal(double x, double min, double max, double step, double a) {
    return (x==a? 1 : 0); 

}

/*======================================================*/
/*  MembershipFunction MF_xfl_trapezoid                 */
/*======================================================*/

/*------------------------------------------------------*/
/* Function to compute an equal relationship            */
/*------------------------------------------------------*/

static double MF_xfl_trapezoid_equal(double x, double min, double max, double step, double a, double b, double c, double d) {
    return (x<a || x>d? 0: (x<b? (x-a)/(b-a) : (x<c?1 : (d-x)/(d-c)))); 

}

/*======================================================*/
/*  MembershipFunction MF_xfl_triangle                  */
/*======================================================*/

/*------------------------------------------------------*/
/* Function to compute an equal relationship            */
/*------------------------------------------------------*/

static double MF_xfl_triangle_equal(double x, double min, double max, double step, double a, double b, double c) {
    return (a<x && x<=b? (x-a)/(b-a) : (b<x && x<c? (c-x)/(c-b) : 0)); 

}

/*======================================================*/
/*  Operatorset OP_ope                                  */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the defuzzification method            */
/*------------------------------------------------------*/

static double OP_ope_Defuz(FuzzyNumber mf) {
 double min = mf.min;
 double max = mf.max;
     double num=0, denom=0;
     int i;
     for(i=0; i<mf.length; i++) {
      num += mf.degree[i] * mf.conc[i].center();
      denom += mf.degree[i];
     }
     if(denom==0) return (min+max)/2;
     return num/denom;

}


/*======================================================*/
/*  TypeLV TP_salida_t                                  */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the label MIN                         */
/*------------------------------------------------------*/

static double TP_salida_t_MIN_equal(double x){
   return MF_xfl_singleton_equal(x,0.0,100.0,0.39215686274509803,0.0);
}

static double TP_salida_t_MIN_center(){
   return 0.0;
}

/*------------------------------------------------------*/
/* Description of the label BAJO                        */
/*------------------------------------------------------*/

static double TP_salida_t_BAJO_equal(double x){
   return MF_xfl_singleton_equal(x,0.0,100.0,0.39215686274509803,25.0);
}

static double TP_salida_t_BAJO_center(){
   return 25.0;
}

/*------------------------------------------------------*/
/* Description of the label MEDIO                       */
/*------------------------------------------------------*/

static double TP_salida_t_MEDIO_equal(double x){
   return MF_xfl_singleton_equal(x,0.0,100.0,0.39215686274509803,50.0);
}

static double TP_salida_t_MEDIO_center(){
   return 50.0;
}

/*------------------------------------------------------*/
/* Description of the label ALTO                        */
/*------------------------------------------------------*/

static double TP_salida_t_ALTO_equal(double x){
   return MF_xfl_singleton_equal(x,0.0,100.0,0.39215686274509803,75.0);
}

static double TP_salida_t_ALTO_center(){
   return 75.0;
}

/*------------------------------------------------------*/
/* Description of the label MAX                         */
/*------------------------------------------------------*/

static double TP_salida_t_MAX_equal(double x){
   return MF_xfl_singleton_equal(x,0.0,100.0,0.39215686274509803,100.0);
}

static double TP_salida_t_MAX_center(){
   return 100.0;
}

/*======================================================*/
/*  TypeLV TP_error_t                                   */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the label EN_MA                       */
/*------------------------------------------------------*/

static double TP_error_t_EN_MA_equal(double x){
   return MF_xfl_trapezoid_equal(x,-30.0,30.0,0.23529411764705882,-37.5,-30.0,-15.5,-12.0);
}

/*------------------------------------------------------*/
/* Description of the label EN_A                        */
/*------------------------------------------------------*/

static double TP_error_t_EN_A_equal(double x){
   return MF_xfl_triangle_equal(x,-30.0,30.0,0.23529411764705882,-15.0,-12.0,-9.0);
}

/*------------------------------------------------------*/
/* Description of the label EN_M                        */
/*------------------------------------------------------*/

static double TP_error_t_EN_M_equal(double x){
   return MF_xfl_triangle_equal(x,-30.0,30.0,0.23529411764705882,-12.0,-9.0,-6.0);
}

/*------------------------------------------------------*/
/* Description of the label EN_B                        */
/*------------------------------------------------------*/

static double TP_error_t_EN_B_equal(double x){
   return MF_xfl_triangle_equal(x,-30.0,30.0,0.23529411764705882,-9.0,-6.0,-3.0);
}

/*------------------------------------------------------*/
/* Description of the label EN_MB                       */
/*------------------------------------------------------*/

static double TP_error_t_EN_MB_equal(double x){
   return MF_xfl_triangle_equal(x,-30.0,30.0,0.23529411764705882,-6.0,-3.0,0.0);
}

/*------------------------------------------------------*/
/* Description of the label EC                          */
/*------------------------------------------------------*/

static double TP_error_t_EC_equal(double x){
   return MF_xfl_triangle_equal(x,-30.0,30.0,0.23529411764705882,-3.0,0.0,3.0);
}

/*------------------------------------------------------*/
/* Description of the label EP                          */
/*------------------------------------------------------*/

static double TP_error_t_EP_equal(double x){
   return MF_xfl_trapezoid_equal(x,-30.0,30.0,0.23529411764705882,0.0,3.0,30.0,37.5);
}

/*======================================================*/
/*  Rulebase RL_reglas                                  */
/*======================================================*/

static void RL_reglas(double error, double *salida) {
 double _rl;

 double _salida_degree[7];
 Consequent _salida_conc[7];
 FuzzyNumber _salida;
 _salida.min = 0.0;
 _salida.max = 100.0;
 _salida.step = 0.39215686274509803;
 _salida.length = 7;
 _salida.degree = _salida_degree;
 _salida.conc = _salida_conc;
 int _salida_i = 0;

 double _error_eq[7];
 _error_eq[0] = TP_error_t_EN_MA_equal(error);
 _error_eq[1] = TP_error_t_EN_A_equal(error);
 _error_eq[2] = TP_error_t_EN_M_equal(error);
 _error_eq[3] = TP_error_t_EN_B_equal(error);
 _error_eq[4] = TP_error_t_EN_MB_equal(error);
 _error_eq[5] = TP_error_t_EC_equal(error);
 _error_eq[6] = TP_error_t_EP_equal(error);

 _rl = _error_eq[0];
 _salida_degree[_salida_i] = _rl;
 _salida_conc[_salida_i].equal = TP_salida_t_MAX_equal;
 _salida_conc[_salida_i].center = TP_salida_t_MAX_center;
 _salida_i++;

 _rl = _error_eq[1];
 _salida_degree[_salida_i] = _rl;
 _salida_conc[_salida_i].equal = TP_salida_t_MAX_equal;
 _salida_conc[_salida_i].center = TP_salida_t_MAX_center;
 _salida_i++;

 _rl = _error_eq[2];
 _salida_degree[_salida_i] = _rl;
 _salida_conc[_salida_i].equal = TP_salida_t_MAX_equal;
 _salida_conc[_salida_i].center = TP_salida_t_MAX_center;
 _salida_i++;

 _rl = _error_eq[3];
 _salida_degree[_salida_i] = _rl;
 _salida_conc[_salida_i].equal = TP_salida_t_MAX_equal;
 _salida_conc[_salida_i].center = TP_salida_t_MAX_center;
 _salida_i++;

 _rl = _error_eq[4];
 _salida_degree[_salida_i] = _rl;
 _salida_conc[_salida_i].equal = TP_salida_t_MAX_equal;
 _salida_conc[_salida_i].center = TP_salida_t_MAX_center;
 _salida_i++;

 _rl = _error_eq[5];
 _salida_degree[_salida_i] = _rl;
 _salida_conc[_salida_i].equal = TP_salida_t_MIN_equal;
 _salida_conc[_salida_i].center = TP_salida_t_MIN_center;
 _salida_i++;

 _rl = _error_eq[6];
 _salida_degree[_salida_i] = _rl;
 _salida_conc[_salida_i].equal = TP_salida_t_MIN_equal;
 _salida_conc[_salida_i].center = TP_salida_t_MIN_center;
 _salida_i++;

 *salida = OP_ope_Defuz(_salida);
}


/*======================================================*/
/*                   Inference Engine                   */
/*======================================================*/

void peep_fuzzy_controllerInferenceEngine(double error, double *_d_salida) {
 double salida;
 RL_reglas(error, &salida);
 *_d_salida = salida;
}

